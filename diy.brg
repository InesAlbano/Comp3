%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"
#include "y.tab.h"

extern FILE *outfp;
char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break labels */

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static char *mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}


static void outstr(char *s) {
  while (*s) fprintf(outfp, pfCHAR, (unsigned char)*s++);
  fprintf(outfp, pfCHAR, 0);
}

static char *extrns[100];
static int extcnt;
%}

%term END = ';' PAUSE = ',' BLOCK = '{' OPEN = '('
%term ALLOC = '#' FACT = '!' ADD = '+' SUB = '-' MUL = '*' DIV = '/' MOD = '%'
%term LT = '<' GT = '>' EQ = '=' AND = '&' OR = '|'
%include "y.tab.h"

%%
blocop: NIL                   0 { }
blocop: bloco                 0 { }

bloco: BLOCK(list, decls)     1 { }

decls: NIL                    0 { }
decls: END(decls, base)       1 { }
decls: END(decls, param)      1 { }

param: PARAM(INTEGER, ID)     1 { }
param: PARAM(STRING, ID)      1 { }
param: PARAM(NUMBER, ID)      1 { }

base: VOID                    0 { }
base: expr                    0 {fprintf(outfp, pfTRASH, pfWORD);}
base: ALLOC(expr, lv)         1 { }

list: NIL                     0 { }
list: END(list, base)         1 { }

args: NIL                     0 {p->place = 0;}
args: PAUSE(args, expr)       1 {p->place =  ((LEFT_CHILD(p)->place) + 1);  }

lv: LOCAL                     1 {fprintf(outfp, pfLOCAL, p->value.i * (pfWORD/4)); }
lv: ID                        1 {fprintf(outfp, pfADDR, p->value.s); }

expr: INT                     0 {fprintf(outfp, pfIMM, p->value.i);}
expr: STR                     0 {fprintf(outfp, pfRODATA pfALIGN pfLABEL, mklbl(++lbl)); outstr(p->value.s); fprintf(outfp, pfTEXT pfADDR, mklbl(lbl));}
expr: REAL                    0 {fprintf(outfp, pfRODATA pfALIGN pfLABEL pfDOUBLE pfTEXT pfADDR pfLOAD2, mklbl(++lbl), p->value.r, mklbl(lbl));}
expr: lv
assign: expr                  1 {fprintf(outfp, pfDUP);}
expr: CALL(ID, args)          1 {fprintf(outfp, pfCALL, mkfunc(LEFT_CHILD(p)->value.s)); if (RIGHT_CHILD(p)->place) fprintf(outfp, pfTRASH, (int)(pfWORD*(RIGHT_CHILD(p)->place)));}
expr: ATR(assign, lv)         1 {fprintf(outfp, pfSTORE);}
expr: ATR(expr, ID)           1 {fprintf(outfp, pfDUP pfADDRA, RIGHT_CHILD(p)->value.s);}
expr: ATR(expr, LOCAL)        1 {fprintf(outfp, pfDUP pfLOCA, RIGHT_CHILD(p)->value.i * (pfWORD/4));}
expr: PTR(lv)                 1 { }
expr: UMINUS(expr)            1 {fprintf(outfp, pfNEG);}
expr: NOT(expr)               1 {fprintf(outfp, pfIMM pfEQ, 0);}
expr: REF(expr)               1 { }
expr: FACT(expr)              1 { }
expr: INCR(INT, lv)           1 {fprintf(outfp, pfINCR, LEFT_CHILD(p)->value.i);}
expr: DECR(INT, lv)           1 {fprintf(outfp, pfDECR, LEFT_CHILD(p)->value.i);}
expr: POSINC(lv, INT)         1 {fprintf(outfp, pfINCR, RIGHT_CHILD(p)->value.i);}
expr: POSDEC(lv, INT)         1 {fprintf(outfp, pfDECR, RIGHT_CHILD(p)->value.i);}
expr:	ADD(expr, expr)	        1 {fprintf(outfp, pfADD);}
expr:	SUB(expr, expr)	        1 {fprintf(outfp, pfSUB);}
expr:	MUL(expr, expr)	        1 {fprintf(outfp, pfMUL);}
expr:	DIV(expr, expr)	        1 {fprintf(outfp, pfDIV);}
expr:	MOD(expr, expr)	        1 {fprintf(outfp, pfMOD);}
expr:	LT(expr, expr)	        1 {fprintf(outfp, pfLT);}
expr:	GT(expr, expr)	        1 {fprintf(outfp, pfGT);}
expr:	GE(expr, expr)	        1 {fprintf(outfp, pfGE);}
expr:	LE(expr, expr)	        1 {fprintf(outfp, pfLE);}
expr: NE(expr, expr)          1 {fprintf(outfp, pfNE);}
expr: EQ(expr, expr)          1 {fprintf(outfp, pfEQ);}
expr: AND(and, expr)          1 {fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place));}
and: expr                     1 { }
expr: OR(or, expr)            1 { }
or: expr                      1 { }
%%

extern void yyerror(const char*);
extern char **yynames;
extern int trace;

void externs(){
  int i;

  for (i = 0; i < extcnt; i++)
    if (extrns[i])
      fprintf(outfp, pfEXTRN, extrns[i]);
}


void initfunc(char *name, int enter, Node *finit, int tipo)
{
  int i;
  extern int errors, trace;
  extern char **yynames;
  if (errors) return;
  if (finit->attrib == NIL) {
    extrns[extcnt++] = dupstr(mkfunc(name));
    return;
  }
  if (trace) printNode(finit, 0, yynames);
  fflush(stdout);
  fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), enter * (pfWORD/4));
  yyselect(finit);
  if (tipo)
    fprintf(outfp, pfLOCV pfPOP pfLEAVE pfRET, -4); /* has return type */
  else
    fprintf(outfp, pfPOP pfLEAVE pfRET); /* is void  */
  freeNode(finit);

}

void variable(char *name, int isConst, Node *type, Node *init) {
  if (isConst)
    fprintf(outfp, pfRODATA pfALIGN pfLABEL pfGLOBL, name, name, pfOBJ);
  else
    fprintf(outfp, pfDATA pfALIGN pfLABEL pfGLOBL, name, name , pfOBJ);

  if(init == NULL){
    if (type->attrib == INTEGER)
      fprintf(outfp, pfINTEGER, 0);
  } else {
    if (init->info == 1) {                           /* integer */
      fprintf(outfp, pfINTEGER, init->value.i);
    } else if (init->info > 10) {                    /* ID */
      fprintf(outfp, pfID, init->value.s);
    } else if (init->info==2 || init->info==(2+5)) { /* string */
			fprintf(outfp, pfRODATA pfALIGN pfLABEL, mklbl(++lbl));
			outstr(init->value.s);
			fprintf(outfp, pfDATA pfID, mklbl(lbl));
    } else {
      char *l = mklbl(++lbl);
      fprintf(outfp, pfRODATA pfALIGN pfLABEL pfDOUBLE pfTEXT pfADDR pfLOAD2, l, init->value.r, l);
    }
  }
}
